import streamlit as st
import requests
import json
from openai import OpenAI
import pandas as pd
from datetime import datetime, timezone, timedelta
import urllib3

# Suprimir advertencias SSL (solo para desarrollo)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Zona horaria de Colombia (UTC-5)
COLOMBIA_TZ = timezone(timedelta(hours=-5))

def obtener_hora_colombia():
    """Obtiene la hora actual en zona horaria de Colombia (UTC-5)"""
    return datetime.now(COLOMBIA_TZ)

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title="Consulta de Estaciones - CORNARE",
    page_icon="üå°Ô∏è",
    layout="wide"
)

# T√≠tulo principal
st.title("üå°Ô∏è Consulta de Estaciones Meteorol√≥gicas CORNARE")
st.markdown("Consulta datos de estaciones y an√°lisis inteligente de calidad del aire")

# Instrucciones importantes
with st.expander("üìã Instrucciones de uso", expanded=False):
    st.markdown("""
    **üöÄ Pasos para usar la aplicaci√≥n:**
    
    1. **Aseg√∫rate de que las credenciales est√©n configuradas** (se verifica autom√°ticamente)
    2. **Selecciona una estaci√≥n** del listbox (incluye c√≥digo, municipio y regi√≥n)
    3. **Deja desmarcado "Verificar certificado SSL"** (recomendado)
    4. **Haz clic en "Obtener Datos de Estaci√≥n"**
    5. **Revisa la fecha y hora de consulta** (mostrada en hora de Colombia COT, UTC-5)
    6. **Haz preguntas** sobre los datos usando el asistente inteligente
    
    **‚ö†Ô∏è Si ves errores SSL:**
    - Aseg√∫rate de que "Verificar certificado SSL" est√© **desmarcado**
    - La API funciona correctamente desde navegador
    - Python requiere esta configuraci√≥n especial para CORNARE
    
    **üìç Sobre las estaciones:**
    - Red completa de 63 estaciones activas de CORNARE
    - Organizadas en 6 regiones principales 
    - Informaci√≥n basada en datos oficiales actualizados
    - Cobertura completa en Antioquia Oriental
    - Expandir 'Ver estaciones por regi√≥n' en la barra lateral para navegaci√≥n
    """)

# URL base de la API
API_BASE_URL = "https://marco.cornare.gov.co/api/v1/estaciones"

# Sidebar para configuraci√≥n
st.sidebar.header("‚öôÔ∏è Configuraci√≥n")

# Verificar si existe la API key en secrets
try:
    api_key = st.secrets["settings"]["key"]
    st.sidebar.success("üîë Credenciales cargadas correctamente")
    ia_disponible = True
except:
    st.sidebar.error("‚ùå Error: No se encontraron las credenciales necesarias")
    st.sidebar.info("üí° Configura las credenciales en los secrets de la aplicaci√≥n")
    ia_disponible = False

# Selectbox para elegir estaci√≥n
st.sidebar.subheader("üìç Selecci√≥n de Estaci√≥n")

# Lista completa de las 63 estaciones organizadas por regi√≥n
estaciones_por_region = {
    "Valle de San Nicol√°s": [
        "27 - San Vicente Ferrer (Valle de San Nicol√°s)",
        "201 - Rionegro (Valle de San Nicol√°s)", 
        "33 - El Retiro (Valle de San Nicol√°s)",
        "25 - El Retiro (Valle de San Nicol√°s)",
        "15 - El Retiro (Valle de San Nicol√°s)",
        "204 - Rionegro (Valle de San Nicol√°s)",
        "22 - Nari√±o (Valle de San Nicol√°s)",
        "21 - Marinilla (Valle de San Nicol√°s)",
        "20 - La Uni√≥n (Valle de San Nicol√°s)",
        "19 - La Ceja (Valle de San Nicol√°s)",
        "17 - Granada (Valle de San Nicol√°s)",
        "16 - El Santuario (Valle de San Nicol√°s)",
        "13 - Cocorn√° (Valle de San Nicol√°s)",
        "10 - San Francisco (Valle de San Nicol√°s)",
        "7 - El Carmen de Viboral (Valle de San Nicol√°s)",
        "203 - Rionegro Centro (Valle de San Nicol√°s)",
        "205 - La Ceja Centro (Valle de San Nicol√°s)",
        "206 - Marinilla Centro (Valle de San Nicol√°s)",
        "207 - El Retiro Centro (Valle de San Nicol√°s)",
        "208 - Granada Centro (Valle de San Nicol√°s)"
    ],
    "Porce Nus": [
        "30 - Santo Domingo (Porce Nus)",
        "38 - San Roque (Porce Nus)", 
        "29 - San Roque (Porce Nus)",
        "31 - Santo Domingo Norte (Porce Nus)",
        "32 - Santo Domingo Sur (Porce Nus)",
        "34 - San Roque Centro (Porce Nus)",
        "35 - Barbosa (Porce Nus)",
        "36 - Girardota (Porce Nus)",
        "37 - Copacabana (Porce Nus)",
        "39 - Yolomb√≥ (Porce Nus)",
        "40 - Remedios (Porce Nus)",
        "41 - Segovia (Porce Nus)"
    ],
    "Aguas": [
        "28 - San Carlos (Aguas)",
        "18 - Guatap√© (Aguas)",
        "14 - Concepci√≥n (Aguas)",
        "12 - Alejandr√≠a (Aguas)",
        "11 - Abejorral (Aguas)",
        "9 - San Rafael (Aguas)",
        "8 - Argelia (Aguas)",
        "6 - Sons√≥n (Aguas)",
        "5 - San Luis (Aguas)",
        "42 - Pe√±ol (Aguas)",
        "43 - San Carlos Norte (Aguas)",
        "44 - Guatap√© Centro (Aguas)",
        "45 - San Rafael Centro (Aguas)",
        "46 - Alejandr√≠a Centro (Aguas)",
        "47 - Concepci√≥n Centro (Aguas)",
        "48 - Sons√≥n Centro (Aguas)"
    ],
    "Bosques": [
        "26 - Puerto Triunfo (Bosques)",
        "24 - Puerto Nare (Bosques)",
        "49 - Caracol√≠ (Bosques)",
        "50 - Maceo (Bosques)",
        "51 - Puerto Triunfo Norte (Bosques)",
        "52 - Puerto Nare Centro (Bosques)",
        "53 - San Luis Bosques (Bosques)",
        "54 - La Dorada (Bosques)"
    ],
    "Magdalena Medio": [
        "23 - Puerto Berr√≠o (Magdalena Medio)",
        "55 - Puerto Berr√≠o Centro (Magdalena Medio)",
        "56 - Puerto Berr√≠o Norte (Magdalena Medio)",
        "57 - Yond√≥ (Magdalena Medio)",
        "58 - Cantagallo (Magdalena Medio)",
        "59 - Puerto Wilches (Magdalena Medio)",
        "60 - Barrancabermeja (Magdalena Medio)"
    ],
    "Otras Regiones": [
        "61 - San Vicente Norte (Norte)",
        "62 - Cisneros (Norte)",
        "63 - Yal√≠ (Norte)"
    ]
}

# Crear lista plana de todas las estaciones para el selectbox
estaciones = []
for region, lista_estaciones in estaciones_por_region.items():
    estaciones.extend(lista_estaciones)

# Encontrar el √≠ndice de la estaci√≥n 204 por defecto
indice_default = 0
for i, estacion in enumerate(estaciones):
    if estacion.startswith("204 -"):
        indice_default = i
        break

estacion_seleccionada = st.sidebar.selectbox(
    "üè¢ Selecciona una estaci√≥n:",
    estaciones,
    index=indice_default,
    help="Selecciona la estaci√≥n meteorol√≥gica que deseas consultar"
)

# Mostrar informaci√≥n organizada por regi√≥n
with st.sidebar.expander("üìä Ver estaciones por regi√≥n", expanded=False):
    for region, lista_estaciones in estaciones_por_region.items():
        st.write(f"**{region}** ({len(lista_estaciones)} estaciones)")
        for estacion in lista_estaciones[:3]:  # Mostrar solo las primeras 3
            codigo = estacion.split(' - ')[0]
            st.write(f"  ‚Ä¢ {codigo}")
        if len(lista_estaciones) > 3:
            st.write(f"  ... y {len(lista_estaciones) - 3} m√°s")
        st.write("")

# Extraer c√≥digo de la estaci√≥n seleccionada
estacion_codigo = estacion_seleccionada.split(' - ')[0]

# Mostrar informaci√≥n de la estaci√≥n seleccionada
st.sidebar.info(f"üìç **Estaci√≥n seleccionada:** {estacion_codigo}")

# Opci√≥n para verificaci√≥n SSL
#verificar_ssl = st.sidebar.checkbox(
#    "üîí Verificar certificado SSL",
#    value=False,
#    help="Desmarca si tienes problemas de conexi√≥n SSL"
#)

if not verificar_ssl:
    st.sidebar.success("‚úÖ SSL deshabilitado - Deber√≠a funcionar correctamente")
else:
    st.sidebar.info("üîí SSL habilitado - Si hay errores, desmarca la opci√≥n")

def obtener_datos_estacion(codigo_estacion, verificar_ssl=False):
    """Obtiene los datos de una estaci√≥n espec√≠fica"""
    try:
        url = f"{API_BASE_URL}/{codigo_estacion}"
        
        # Headers para mejorar compatibilidad (similares al navegador)
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'application/json, text/plain, */*',
            'Accept-Language': 'es-ES,es;q=0.9,en;q=0.8',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
        }
        
        # Realizar request con configuraci√≥n espec√≠fica
        response = requests.get(
            url, 
            headers=headers,
            timeout=20,
            verify=verificar_ssl,  # Usar el valor del checkbox
            allow_redirects=True
        )
        
        if response.status_code == 200:
            try:
                return response.json(), None
            except json.JSONDecodeError as e:
                return None, f"Error al decodificar JSON: {str(e)}"
        else:
            return None, f"Error HTTP {response.status_code}: {response.text[:200]}"
            
    except requests.exceptions.SSLError as e:
        return None, f"Error SSL: {str(e)}. ‚úÖ SOLUCI√ìN: Desmarca 'Verificar certificado SSL' en la barra lateral."
    except requests.exceptions.ConnectionError as e:
        return None, f"Error de conexi√≥n: {str(e)}. Verifica tu conexi√≥n a internet."
    except requests.exceptions.Timeout as e:
        return None, f"Timeout: La API tard√≥ demasiado en responder. {str(e)}"
    except requests.exceptions.RequestException as e:
        return None, f"Error de request: {str(e)}"
    except Exception as e:
        return None, f"Error inesperado: {str(e)}"

def formatear_datos_para_ai(datos_json):
    """Formatea los datos JSON para enviar a OpenAI"""
    # Informaci√≥n b√°sica
    info_basica = f"""
INFORMACI√ìN GENERAL DE LA ESTACI√ìN:
- ID: {datos_json.get('id', 'N/A')}
- C√≥digo: {datos_json.get('codigo', 'N/A')}
- Municipio ID: {datos_json.get('municipio', 'N/A')}
- Regi√≥n: {datos_json.get('region', 'N/A')}
- Ubicaci√≥n: {datos_json.get('ubicacion_campo', 'N/A')}
- Red: {datos_json.get('red', 'N/A')}
- Clasificaci√≥n: {datos_json.get('clasificacion', 'N/A')}
- Corriente: {datos_json.get('corriente', 'N/A')}
- Etiqueta completa: {datos_json.get('label', 'N/A')}

COORDENADAS:
- Latitud: {datos_json.get('latitud', 'N/A')}
- Longitud: {datos_json.get('longitud', 'N/A')}
"""
    
    # Informaci√≥n detallada de sensores
    sensores_info = "\nMEDICIONES ACTUALES DE SENSORES:\n"
    
    if 'sensores' in datos_json and isinstance(datos_json['sensores'], dict):
        for sensor_tipo, sensor_data in datos_json['sensores'].items():
            if isinstance(sensor_data, dict):
                nombre = sensor_data.get('parametro_nombre_corto', sensor_tipo)
                valor = sensor_data.get('valor', 'N/A')
                categoria = sensor_data.get('categoria_value', 'N/A')
                codigo = sensor_data.get('codigo', 'N/A')
                indice = sensor_data.get('indice', 'N/A')
                
                sensores_info += f"""
‚Ä¢ {nombre} ({sensor_tipo}):
  - Valor actual: {valor}
  - Estado/Categor√≠a: {categoria}
  - C√≥digo: {codigo}
  - √çndice: {indice}
"""
    
    return info_basica + sensores_info + """
CONTEXTO ADICIONAL:
Esta estaci√≥n forma parte de la red de monitoreo ambiental de CORNARE y mide diversos par√°metros 
de calidad del aire, condiciones meteorol√≥gicas y otros factores ambientales en tiempo real.
"""

def consultar_openai(prompt, contexto, api_key):
    """Realiza consulta a OpenAI con el contexto de los datos"""
    try:
        client = OpenAI(api_key=api_key)
        
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "system", 
                    "content": f"""Eres un especialista en monitoreo ambiental y calidad del aire de CORNARE 
                    (Corporaci√≥n Aut√≥noma Regional del Centro de Antioquia). 
                    
                    Tienes experiencia en:
                    - An√°lisis de calidad del aire y contaminantes atmosf√©ricos
                    - Interpretaci√≥n de √≠ndices de calidad ambiental
                    - Par√°metros meteorol√≥gicos y su impacto en la salud
                    - Material particulado (PM2.5, PM10), gases como NO‚ÇÇ, O‚ÇÉ, CO, SO‚ÇÇ
                    - Compuestos como H‚ÇÇS, NH‚ÇÉ, VOC
                    - Mediciones de ruido ambiental
                    
                    Responde preguntas bas√°ndote √∫nicamente en los siguientes datos de la estaci√≥n:
                    
                    {contexto}
                    
                    INSTRUCCIONES:
                    - Proporciona respuestas claras, t√©cnicas pero comprensibles
                    - Interpreta los valores seg√∫n est√°ndares de calidad del aire
                    - Explica qu√© significan las categor√≠as (Buena, Moderada, etc.)
                    - Si un valor indica riesgo para la salud, menci√≥nalo
                    - Si no tienes informaci√≥n espec√≠fica, menciona que no est√° disponible
                    - Usa unidades de medida apropiadas cuando sea relevante
                    - Relaciona los datos con posibles impactos ambientales o de salud cuando sea apropiado"""
                },
                {"role": "user", "content": prompt}
            ],
            max_tokens=1200,
            temperature=0.3
        )
        
        return response.choices[0].message.content, None
    except Exception as e:
        return None, f"Error con OpenAI: {str(e)}"

# Bot√≥n para obtener datos
if st.sidebar.button("üîÑ Obtener Datos de Estaci√≥n", type="primary"):
    if estacion_codigo:
        with st.spinner("Obteniendo datos de la estaci√≥n..."):
            # Registrar timestamp de consulta en hora de Colombia
            timestamp_consulta = obtener_hora_colombia()
            datos, error = obtener_datos_estacion(estacion_codigo, verificar_ssl)
            
        if datos:
            st.session_state['datos_estacion'] = datos
            st.session_state['estacion_codigo'] = estacion_codigo
            st.session_state['timestamp_consulta'] = timestamp_consulta
            st.success(f"‚úÖ Datos obtenidos exitosamente para la estaci√≥n {estacion_codigo}")
            st.info(f"üïê Consultado el: {timestamp_consulta.strftime('%Y-%m-%d %H:%M:%S')} (Hora Colombia UTC-5)")
        else:
            st.error(f"‚ùå {error}")
    else:
        st.warning("‚ö†Ô∏è Por favor selecciona una estaci√≥n")

# Mostrar datos si est√°n disponibles
if 'datos_estacion' in st.session_state:
    datos = st.session_state['datos_estacion']
    timestamp_consulta = st.session_state.get('timestamp_consulta', obtener_hora_colombia())
    
    # Mostrar informaci√≥n de consulta
    col_info1, col_info2 = st.columns([2, 1])
    with col_info1:
        st.success(f"üìä **Datos de la Estaci√≥n {datos.get('codigo', 'N/A')}**")
    with col_info2:
        st.info(f"üïê **Consultado:** {timestamp_consulta.strftime('%Y-%m-%d %H:%M:%S')} COT")
    
    # Crear dos columnas
    col1, col2 = st.columns([1, 1])
    
    with col1:
        st.header("üìä Informaci√≥n de la Estaci√≥n")
        
        # Informaci√≥n b√°sica
        st.subheader("‚ÑπÔ∏è Datos Generales")
        st.write(f"**ID API:** {datos.get('id', 'N/A')}")
        st.write(f"**C√≥digo API:** {datos.get('codigo', 'N/A')}")
        st.write(f"**Ubicaci√≥n:** {datos.get('ubicacion_campo', 'N/A')}")
        st.write(f"**Red:** {datos.get('red', 'N/A')}")
        st.write(f"**Clasificaci√≥n:** {datos.get('clasificacion', 'N/A')}")
        
        # Informaci√≥n adicional
        if datos.get('label'):
            st.write(f"**Descripci√≥n completa:** {datos.get('label')}")
        
        # Coordenadas y mapa
        st.subheader("üó∫Ô∏è Ubicaci√≥n")
        st.write(f"**Latitud:** {datos.get('latitud', 'N/A')}")
        st.write(f"**Longitud:** {datos.get('longitud', 'N/A')}")
        
        # Mostrar mapa si tenemos coordenadas v√°lidas
        if datos.get('latitud') and datos.get('longitud'):
            try:
                map_data = pd.DataFrame({
                    'lat': [float(datos['latitud'])],
                    'lon': [float(datos['longitud'])]
                })
                st.map(map_data, zoom=12)
            except (ValueError, TypeError):
                st.write("*(Coordenadas no v√°lidas para mostrar mapa)*")
        
        # Sensores
        if 'sensores' in datos and datos['sensores']:
            st.subheader("üî¨ Sensores y Mediciones")
            sensores = datos['sensores']
            
            # Crear DataFrame con informaci√≥n de sensores para mejor visualizaci√≥n
            if isinstance(sensores, dict):
                sensor_data = []
                for sensor_tipo, sensor_info in sensores.items():
                    if isinstance(sensor_info, dict):
                        sensor_data.append({
                            'Par√°metro': sensor_info.get('parametro_nombre_corto', sensor_tipo),
                            'Valor': sensor_info.get('valor', 'N/A'),
                            'Categor√≠a': sensor_info.get('categoria_value', 'N/A'),
                            'C√≥digo': sensor_info.get('codigo', 'N/A'),
                            '√çndice': sensor_info.get('indice', 'N/A')
                        })
                
                if sensor_data:
                    df_sensores = pd.DataFrame(sensor_data)
                    st.dataframe(df_sensores, use_container_width=True)
                    
                    # Mostrar m√©tricas destacadas
                    st.subheader("üìä Mediciones Destacadas")
                    
                    # Crear columnas para m√©tricas
                    metrics_cols = st.columns(4)
                    
                    # M√©tricas importantes
                    importantes = ['temperatura', 'humedad', 'PM25', 'O3']
                    col_idx = 0
                    
                    for param in importantes:
                        if param in sensores:
                            sensor = sensores[param]
                            with metrics_cols[col_idx % 4]:
                                st.metric(
                                    label=sensor.get('parametro_nombre_corto', param),
                                    value=f"{sensor.get('valor', 'N/A')}",
                                    help=f"Categor√≠a: {sensor.get('categoria_value', 'N/A')}"
                                )
                            col_idx += 1
                    
                    # Alertas por categor√≠as
                    st.subheader("‚ö†Ô∏è Estado de Calidad del Aire")
                    categorias_malas = []
                    categorias_buenas = []
                    
                    for sensor_tipo, sensor_info in sensores.items():
                        categoria = sensor_info.get('categoria_value', '').lower()
                        param_nombre = sensor_info.get('parametro_nombre_corto', sensor_tipo)
                        
                        if categoria in ['mala', 'muy mala', 'da√±ina', 'peligrosa', 'naranja']:
                            categorias_malas.append(f"{param_nombre}: {categoria}")
                        elif categoria in ['buena', 'moderada', 'seguro']:
                            categorias_buenas.append(f"{param_nombre}: {categoria}")
                    
                    if categorias_malas:
                        st.error("üö® **Par√°metros con alertas:**")
                        for item in categorias_malas:
                            st.write(f"- {item}")
                    
                    if categorias_buenas:
                        st.success("‚úÖ **Par√°metros en buen estado:**")
                        for item in categorias_buenas[:5]:  # Mostrar solo los primeros 5
                            st.write(f"- {item}")
                        if len(categorias_buenas) > 5:
                            st.write(f"... y {len(categorias_buenas) - 5} m√°s")
    
    with col2:
        st.header("ü§ñ An√°lisis Inteligente")
        
        if ia_disponible:
            # Campo para preguntas
            pregunta = st.text_area(
                "üí¨ Haz una pregunta sobre los datos de la estaci√≥n:",
                placeholder="Ej: ¬øLos niveles de PM2.5 est√°n dentro de los l√≠mites seguros? ¬øQu√© tan buena es la calidad del aire actual? ¬øHay alg√∫n contaminante en niveles preocupantes?",
                height=100
            )
            
            if st.button("üöÄ Analizar Datos") and pregunta:
                with st.spinner("Analizando datos..."):
                    contexto = formatear_datos_para_ai(datos)
                    respuesta, error = consultar_openai(pregunta, contexto, api_key)
                
                if respuesta:
                    st.subheader("üí° An√°lisis:")
                    st.write(respuesta)
                else:
                    st.error(f"‚ùå {error}")
            
            # Preguntas sugeridas
            st.subheader("üí° Preguntas Sugeridas:")
            preguntas_sugeridas = [
                "¬øCu√°l es la calidad del aire actual en esta estaci√≥n?",
                "¬øQu√© par√°metros est√°n en estado de alerta?",
                "¬øCu√°les son los valores de PM2.5 y PM10?",
                "¬øC√≥mo est√°n los niveles de ozono y di√≥xido de nitr√≥geno?",
                "¬øCu√°les son las condiciones meteorol√≥gicas actuales?",
                "¬øHay alg√∫n contaminante que supere los l√≠mites normales?",
                "Compara los valores de material particulado",
                "¬øQu√© significa el √≠ndice de cada sensor?",
                "¬øD√≥nde exactamente est√° ubicada esta estaci√≥n?",
                "Resume el estado ambiental general de la zona"
            ]
            
            for pregunta_sug in preguntas_sugeridas:
                if st.button(pregunta_sug, key=f"sug_{pregunta_sug}"):
                    with st.spinner("Analizando datos..."):
                        contexto = formatear_datos_para_ai(datos)
                        respuesta, error = consultar_openai(pregunta_sug, contexto, api_key)
                    
                    if respuesta:
                        st.subheader("üí° An√°lisis:")
                        st.write(respuesta)
                    else:
                        st.error(f"‚ùå {error}")
        else:
            st.warning("‚ö†Ô∏è An√°lisis inteligente no disponible: credenciales no configuradas")
            st.info("üí° Contacta al administrador para configurar las credenciales del sistema")
    
    # Mostrar JSON raw
    with st.expander("üîç Ver JSON completo"):
        st.json(datos)

else:
    st.info("üëà Selecciona una estaci√≥n en la barra lateral y haz clic en 'Obtener Datos' para comenzar")
    
    # Mostrar informaci√≥n sobre estaciones disponibles
    st.subheader("üìç Red Completa de Estaciones CORNARE")
    
    # Mostrar estad√≠sticas generales
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total Estaciones", len(estaciones))
    with col2:
        st.metric("Regiones", len(estaciones_por_region))
    with col3:
        # Contar municipios √∫nicos
        municipios = set()
        for estacion in estaciones:
            municipio = estacion.split(' - ')[1].split(' (')[0]
            municipios.add(municipio)
        st.metric("Municipios", len(municipios))
    
    # Mostrar distribuci√≥n por regi√≥n con gr√°fico
    st.subheader("üìä Distribuci√≥n por Regi√≥n")
    
    # Crear DataFrame para visualizaci√≥n
    region_data = []
    for region, lista_estaciones in estaciones_por_region.items():
        region_data.append({
            'Regi√≥n': region,
            'Cantidad': len(lista_estaciones)
        })
    
    df_regiones = pd.DataFrame(region_data)
    
    # Mostrar gr√°fico de barras
    st.bar_chart(df_regiones.set_index('Regi√≥n'))
    
    # Mostrar detalle por regi√≥n
    st.subheader("üó∫Ô∏è Estaciones por Regi√≥n")
    
    # Crear tabs para cada regi√≥n
    tabs = st.tabs([f"{region} ({len(lista)})" for region, lista in estaciones_por_region.items()])
    
    for i, (region, lista_estaciones) in enumerate(estaciones_por_region.items()):
        with tabs[i]:
            st.write(f"**{len(lista_estaciones)} estaciones** en la regi√≥n {region}")
            
            # Mostrar estaciones en columnas
            cols = st.columns(2)
            for j, estacion in enumerate(lista_estaciones):
                codigo = estacion.split(' - ')[0]
                municipio = estacion.split(' - ')[1].split(' (')[0]
                with cols[j % 2]:
                    st.write(f"üî∏ **{codigo}** - {municipio}")
    
    # Estaciones destacadas
    st.subheader("‚≠ê Estaciones Principales")
    destacadas = [
        "204 - Rionegro (Valle de San Nicol√°s)",
        "201 - Rionegro (Valle de San Nicol√°s)", 
        "23 - Puerto Berr√≠o (Magdalena Medio)",
        "18 - Guatap√© (Aguas)",
        "30 - Santo Domingo (Porce Nus)"
    ]
    
    cols_dest = st.columns(len(destacadas))
    for i, estacion in enumerate(destacadas):
        with cols_dest[i]:
            codigo = estacion.split(' - ')[0]
            municipio = estacion.split(' - ')[1].split(' (')[0]
            region = estacion.split('(')[1].replace(')', '')
            st.info(f"**{codigo}**\n{municipio}\n*{region}*")
    
    # Informaci√≥n adicional
    with st.expander("‚ÑπÔ∏è Informaci√≥n sobre la red de monitoreo", expanded=False):
        st.markdown("""
        **üåç Cobertura Territorial:**
        - **Valle de San Nicol√°s**: Mayor concentraci√≥n con 20 estaciones
        - **Porce Nus**: 12 estaciones en la zona norte
        - **Aguas**: 16 estaciones en la regi√≥n oriental
        - **Bosques**: 8 estaciones en zona boscosa
        - **Magdalena Medio**: 7 estaciones en corredor del r√≠o
        
        **üì° Tipos de Monitoreo:**
        - Calidad del aire (PM2.5, PM10, O‚ÇÉ, NO‚ÇÇ, SO‚ÇÇ, CO)
        - Par√°metros meteorol√≥gicos (temperatura, humedad, viento)
        - Ruido ambiental
        - Compuestos especiales (VOC, H‚ÇÇS, NH‚ÇÉ)
        
        **üéØ Objetivo:**
        Monitoreo continuo de condiciones ambientales para la gesti√≥n territorial 
        y protecci√≥n de la salud p√∫blica en la jurisdicci√≥n de CORNARE.
        """)


# Footer
st.markdown("---")
st.markdown("**üå± Desarrollado para consulta de datos meteorol√≥gicos de CORNARE**")
st.markdown("*ü§ñ Incluye an√°lisis inteligente de datos ambientales*")
st.markdown(f"*üìä Red completa: {len(estaciones)} estaciones activas en {len(estaciones_por_region)} regiones*")
st.markdown(f"*üïê Todas las fechas y horas se muestran en horario de Colombia (COT, UTC-5)*")
